.................................ШПАРГАЛКА ПО МЕТОДАХ...........................
a і b - змінні (як в алгебраїчному рівнянні), це сховища даних, які використовує
програма. Змінна складається із ідентифікатора (імені) і пов'язаного з ним
значення. 2 - просто число. Це називається значенням літерала (literal value),
тому що не берігається у змінній. = і \* - оператори, вчиняють дії над
значеннями і змінними. [2] - вираз значення літерала. [b]і[a] - вирази змінної,
означають необхідність підставити значення змінної, але лише у тому випадку,
якщо змінна складається із правої частини виразу присвоювання. [b * 2] -
арифметичний вираз множення. [a = b * 2] - вираз присвоювання. У нашому випадку
вказує на необхідність обчислення правої частини виразу і присвоювання
результату змінної a у лівій частині виразу. length - метод який містить кіл-ть
символів рядка. сутність.ім`я_метода() Для того, щоб перевести скрипт в суворий
режим, достатньо зазначити директиву на початку js-файлу. Завжди пишіть код в
суворому режимі. script.js "use strict"; // Далі йде увесь код JS-файлу
Невизначена (undefined) - це змінна, яка була оголошена ключовим словом let, але
не ініціалізована значенням. За замовчуванням їй присвоюється початкове значення
undefined. // Оголошення змінної age let age = 20; // ✅ Правильно, звертаємось
після оголошення age = 25; console.log(age); // 25 Number - цілі числа і числа з
плаваючою комою (крапкою). String - рядки, послідовність з нуля або більше
символів. Рядок починається і закінчується одинарними ', або подвійними лапками
". Boolean - логічний тип даних, прапорці стану. Всього два значення: true і
false. Наприклад, на запитання чи увімкнено світло в кімнаті, можна відповісти
так (true) або ні (false). true — так, вірно, істина 1. false — ні, невірно,
неправда, 0 null - особливе значення, яке по суті означає ніщо. Використовується
в тих ситуаціях, коли необхідно явно вказати порожнечу. Наприклад, якщо
користувач нічого не вибрав, то можна сказати що значення null. let
selectedProduct = null; undefined - ще одне спеціальне значення. За
замовчуванням, коли змінна оголошується, але не ініціалізується, її значення не
визначено, їй присвоюється undefined. Оператор typeof Використовується для
отримання типу значення змінної. Повертає на місце свого виклику тип значення
змінної, вказаного після нього - рядок, в якому вказано тип. Для виведення даних
існує два методи: console.log() і alert(). В круглих дужках зазначаємо ім'я
змінної, значення якої необхідно вивести. Отримання даних confirm() - виводить
модальне вікно з повідомленням, і дві кнопки, Ok і Cancel. Натискаючи на Ok,
результатом будет true, натискаючи на Cancel - повертається false. prompt() -
виводить модальне вікно з полем введення і кнопками Ok і Cancel. Натискаючи на
Ok, результатом буде те, що ввів користувач, у випадку Cancel - повертається
null. Важлива особливість prompt полягає в тому, що незалежно від того, що ввів
користувач, завжди повернеться рядок. Тобто, якщо користувач ввів 5, то
повернеться не число 5, а рядок "5". Важливо запам'ятати терміни складових
виразу. + - \* / % називаються оператори, а те, на чому вони застосовуються -
операнди. // ✅ Добре, приведення типів не виконується console.log(5 === 5); //
true console.log(5 !== "5"); // true Приведення до числа Number(val), передаючи
їй у val те, що потрібно привести до числа. Якщо значення привести до числа
неможливо, результатом буде спеціальне числове значення NaN (Not a Number).
Аналогічним чином відбувається перетворення і в інших математичних операторах і
функціях. Метод Number.parseInt() парсить з рядка ціле число.
console.log(Number.parseInt("12.46qwe79")); // 12 Метод Number.parseFloat()
парсить з рядка дробове число. console.log(Number.parseFloat("12.46qwe79")); //
12.46 Для перевірки на число можна використовувати метод Number.isNaN(val). Він
перевіряє, чи вказане значення є NaN. Метод відповідає на запитання "Це Not A
Number?" і повертає: true - якщо значення val - NaN false - якщо значення val -
не NaN Для всіх значень val, крім NaN, при передачі в Number.isNaN(val) поверне
false. Цей метод не намагається перетворити val в число, а просто виконує
перевірку на NaN. Додавання чисел з рухомою крапкою (комою)-- toFixed().
console.log((0.17 + 0.24).toFixed(2)); // 0.41 Клас Math // Math.max(num1, num2,
...) - повертає найбільше ціле число з набору console.log(Math.max(20, 10, 50,
40)); // 50 // Math.min(num1, num2, ...) - повертає найменше ціле число з набору
console.log(Math.min(20, 10, 50, 40)); // 10 // Math.pow(base, exponent) -
піднесення до степеня console.log(Math.pow(2, 4)); // 16 Важливо пам'ятати, що
індексація елементів рядка починається з нуля. Конкатенація рядків + Під час
конкатенації, будь-який тип даних приводиться до рядка і зшивається з рядком,
але є особливість - послідовність запису операндів. Шаблонний рядок береться у
зворотні (косі) лапки, замість подвійних або одинарних, і може містити
заповнювачі місця, які позначаються знаком долара і фігурними дужками -
${вираз}. Методи toLowerCase() і toUpperCase() Повертають новий рядок у
відповідному регістрі, не змінюючи оригінальний рядок. const userInput =
"saMsUng"; const normalizedToUpperCaseInput = userInput.toUpperCase(); Метод
indexOf() Повертає позицію (індекс), на якій знаходиться перший збіг підрядка
або -1, якщо нічого не знайдено. Метод includes() Перевіряє, чи міститься
підрядок в рядку, повертає буль - true, якщо міститься, і false - в іншому
випадку. Регістр символів в рядку і підрядку має значення, оскільки, наприклад,
літера "a" не дорівнює літері "А". Метод endsWith() Дозволяє визначити, чи
завершується рядок символами (підрядком), зазначеними в дужках, повертаючи true
або false Методи replace() і replaceAll() Повертає новий рядок, в якому перше
(replace) або усі збіги (replaceAll) підрядка замінені на вказане значення.
Метод slice() Метод рядків slice (startIndex, endIndex) використовується для
створення копії частини або всього рядка. Він робить копію елементів рядка від
startIndex і до, але не включно endIndex і повертає новий рядок, не змінюючи
оригінал. const productName = "Repair droid"; console.log(productName.slice(0,
4)); // "Repa" Логічні оператори використовуються для перевірки умов з багатьма
виразами, наприклад в операціях порівняння. Запам'ятайте 6 хибних (falsy)
значень, що приводяться до false у логічному перетворенні: 0, NaN, null,
undefined, порожній рядок і false. Абсолютно все інше приводиться до true.
Логічне «І» Оператор && приводить всі операнди до буля і повертає значення
одного з них. Лівий операнд - якщо його можна привести до false, і правий - в
інших випадках. Якщо хоча б один із операндів буде приведений до false,
результатом виразу буде його значення. Тобто, логічне «І» зупиняється на хибному
і повертає те, на чому зупинилось, або останній операнд. Виконуючи логічне «І»,
правий операнд може не обчислюватися у випадку, якщо лівий був приведений до
false. Логічне «АБО» Оператор || приводить всі операнди до буля і повертає
значення одного з них. Лівий операнд - якщо його можна привести до true, і
правий - в інших випадках. Тобто, логічне «АБО» зупиняється на правді і повертає
те, на чому зупинилося або останній операнд. Виконуючи логічне «АБО», правий
операнд може не обчислюватися у випадку, якщо лівий був приведений до true.
Логічне «НЕ» «НЕ» - це унарний оператор, який виконує операцію над одним
операндом з правої сторони. Оператор ! приводить операнд до буля, якщо
необхідно, а потім робить інверсію - змінює його на протилежний true -> false
або false -> true. Тернарний оператор <умова> ? <вираз*якщо*умова*правдива> :
<вираз*якщо*умова*хибна> const num1 = 5; const num2 = 10; biggerNumber = num1 >
num2 ? num1 : num2; Цикл while Цикл з передумовою — цикл, який виконується, доки
правдива якась умова, зазначена до його початку. Ця умова перевіряється до
виконання тіла циклу, тому тіло може не виконатися жодного разу, якщо умова від
самого початку - хибна. Конструкція while створює цикл, який виконує блок коду,
доки умова перевірки оцінюється як true. Цикл do...while Цикл з постумовою -
цикл, в якому умова перевіряється після виконання тіла циклу. З цього випливає,
що тіло завжди виконується хоча б один раз. Цикл for Цикл з лічильником - цикл,
в якому певна змінна змінює своє значення із заданого початкового до кінцевого
значення з деяким кроком, і для кожного значення цієї змінної тіло циклу
виконується один раз. Змінні-лічильники, за традицією, називаються літерами i, j
і k. Оператор break Перервати виконання циклу можна в будь-який момент. Для
цього існує оператор break, який повністю припиняє виконання циклу і передає
управління на рядок після його тіла. Оператор continue Перериває не увесь цикл,
а тільки виконання поточної ітерації. Його використовують, якщо зрозуміло, що на
поточній ітерації циклу більше немає що робити або взагалі не потрібно нічого
робити, і час переходити до наступної ітерації. Масив - структура даних для
зберігання і маніпулювання колекцією індексованих значень. Використовується для
зберігання впорядкованих колекцій даних, наприклад, списку курортів, товарів,
клієнтів в готелі тощо. Ітерація по масиву - Цикл for можна використовувати для
ітерації по масиву, тобто «перебрати» його поелементно. const clients =
["Mango", "Ajax", "Poly"]; for (let i = 0; i < clients.length; i += 1) {
console.log(clients[i]); } Цикл for...of - Конструкція for...of оголошує цикл,
що перебирає ітерабельні об'єкти, як-от масиви і рядки. Тіло циклу буде
виконуватися для значення кожного елемента. Це хороша заміна циклу for, якщо не
потрібен доступ до лічильника ітерації. const clients = ["Mango", "Ajax",
"Poly"]; for (const client of clients) { console.log(client); } Методи масиву --
split(delimiter) перетворює рядок в масив, «розбиваючи» його роздільником
delimiter. Якщо роздільник - це порожній рядок, то створиться масив окремих
символів. Роздільником може бути один або декілька символів. Метод масивів --
join(delimiter) об'єднує елементи масиву у рядок. У рядку елементи будуть
розділені символом або групою символів, зазначених в delimiter. Тобто ця
операція протилежна методу рядків split(delimiter). Метод -- indexOf(value)
повертає перший індекс, в якому елемент зі значенням value був знайдений в
масиві, або число -1, якщо такий елемент відсутній. Використовуйте indexOf тоді,
коли необхідно отримати сам індекс елемента. Метод -- includes(value) перевіряє,
чи містить масив елемент зі значенням value і повертає true або false
відповідно. Застосування цього методу корисне в ситуаціях, коли необхідно
перевірити, чи є елемент в масиві і не важлива його позиція (індекс). Метод --
Метод push() додає один або декілька елементів наприкінці масиву, без
необхідності зазначати індекси елементів, що додаються. Повертає довжину масиву
після додавання елементів. Метод pop() видаляє останній елемент з кінця масиву і
повертає видалений елемент. Якщо масив порожній, метод повертає undefined. Метод
slice() -- slice(begin, end) повертає новий масив, що містить копію частини
вихідного масиву, не змінюючи його. Копія створюється з begin і до, але не
включно, end - індекси елементів вихідного масиву. Якщо begin і end не
зазначені, буде створена повна копія вихідного масиву. Якщо значення start
від'ємне, а end не зазначено - будуть скопійовані останні start елементи Метод
splice() -- Швейцарський ніж для роботи з масивами, якщо вихідний масив
необхідно змінити. Видаляє, додає і замінює елементи у довільному місці масиву.
Метод splice змінює вихідний масив і повертає масив, що містить видалені
елементи. Видалення -- Щоб видалити елементи в масиві, передаються два
аргументи. splice(position, num) position - вказує на позицію (індекс) першого
елемента для видалення num - визначає кількість елементів, що видаляються.
Додавання -- Для того, щоб додати один або декілька елементів в масив, необхідно
передати три або більше аргументи, за такої умови, другий аргумент повинен
дорівнювати нулю. splice(position, 0, new_element_1, new_element_2, ...) Заміна
-- це операція додавання, в якій видаляються елементи в місці додавання нових.
Для цього необхідно передати мінімум три аргументи. Кількість елементів, що
видаляються і додаються, може не збігатися. splice(position, num, new_element_1,
new_element_2, ...) Метод concat() -- Об'єднує два або більше масивів в один.
Він не змінює масив, на якому викликається, а повертає новий. Порядок аргументів
методу впливає на порядок елементів нового масиву. Функція - це підпрограма,
незалежна частина коду, призначена для багаторазового виконання конкретної
задачі з різними початковими значеннями. Функції дозволяють структурувати великі
програми, зменшують повторення та ізолюють код. Параметри та аргументи -- В
круглих дужках після імені функції зазначаються параметри - перелік даних, які
функція очікує на момент виклику. Параметри - це локальні змінні, доступні
тільки у тілі функції. Вони розділяються комами. Параметрів може бути декілька,
або взагалі не бути, у такому випадку записуються просто порожні круглі дужки.
ЦІКАВО Порядок передачі аргументів повинен відповідати порядку оголошених
параметрів: значення першого аргументу буде присвоєно першому параметру, другого
аргументу - другому параметру тощо. Якщо параметрів буде більше, ніж аргументів,
то параметрам без значень буде присвоєно undefined. Повернення значення Оператор
return використовується для передачі значення з тіла функції у зовнішній код.
Коли інтерпретатор зустрічає return, він відразу ж виходить з функції (припиняє
її виконання), і повертає вказане значення у те місце де була викликана функція.
ЦІКАВО Оператор return без явно вказаного значення повертає спеціальне значення
undefined. За відсутності return в тілі функції, вона все одно поверне
undefined. Псевдомасив arguments Доступ до списку всіх аргументів можна отримати
за допомогою спеціальної змінної arguments, яка доступна тільки всередині
функції і зберігає всі аргументи у якості псевдомасиву. Псевдомасив - колекція з
властивістю length і можливістю звернутися до елементу за індексом, але
відсутністю більшості методів для роботи з масивом. Перетворення псевдомасиву --
Зазвичай псевдомасив необхідно перетворити у повноцінний масив, оскільки у
псевдомасиву відсутні методи масиву, наприклад slice() або includes(). На
практиці застосовують декілька основних способів. Використовуючи метод
Array.from(), який створить масив із псевдомасиву. Патерн «Раннє повернення» --
це спосіб використовувати можливість дострокового повернення з функції за
допомогою оператора return. Використовуючи цей прийом, ми отримуємо чистіший,
плоскіший і зрозуміліший код, який простіше рефакторити Функціональний вираз
(function expression) - звичайне оголошення змінної, значенням якої буде
функція. Альтернативний спосіб оголошення функції........... // Оголошення
функції (function declaration) function multiply(x, y, z) {
console.log(`Результат множення дорівнює ${x * y * z}`); } // Функціональний
вираз (function expression) const multiply = function (x, y, z) {
console.log(`Результат множення дорівнює ${x * y * z}`); }; [] - літерал масива.
{} - літерал об'єкта. Доступ до властивостей об'єкта в методах -- Для того, щоб
отримати доступ до властивостей об'єкта в методах, ми звертаємось до нього через
this і далі, стандартно - «через крапку» до властивостей. Цикл for...in -- Для
перебирання об'єктів використовується спеціальний цикл for...in, який перебирає
ключі об'єкта object. Метод hasOwnProperty() Розберемо концепцію власних і
невласних властивостей об'єкта і навчимося правильно використовувати цикл
for...in. Метод Object.create(animal) створює і повертає новий об'єкт, зв'язуючи
його з об'єктом animal. Тому можна отримати значення властивості legs,
звернувшись до нього як dog.legs, хоча він відсутній в об'єкті dog - це невласна
властивість з об'єкта animal. Оператор in, який використовується в циклі
for...in, не робить різниці між власними та невласними властивостями об'єкта. Ця
особливість заважає, оскільки ми завжди хочемо перебрати тільки власні
властивості. Для того, щоб дізнатись, чи містить об'єкт власну властивість,
використовується метод hasOwnProperty(key), який повертає true або false. Метод
Object.keys() -- Вбудований клас Object має декілька корисних методів для роботи
з об'єктами. Перший з них - це Object.keys(obj), який приймає об'єкт і повертає
масив ключів його власних властивостей. Якщо об'єкт не має властивостей, метод
поверне порожній масив. Метод Object.values() -- Якщо метод Object.keys(obj)
повертає масив ключів власних властивостей об'єкта, то метод Object.values(obj)
повертає масив значень його власних властивостей. Якщо в об'єкті відсутні
властивості, метод Object.values(obj) поверне порожній масив. Метод
Object.entries(obj) -- повертає масив записів, кожен елемент якого, буде ще один
масив з 2-х елементів: імені властивості і значення цієї властивості з об'єкта
obj. spread ... : передача аргументів -- Операція ... (spread) дозволяє
розподілити колекцію елементів (масив, рядок або об'єкт) в місце, в якому
очікується набір окремих значень. Звичайно, існують деякі обмеження, наприклад,
не можна розподілити масив в об'єкт і навпаки. spread: створення нового масиву
-- Операція ... (spread) дозволяє створити копію масиву або «склеїти» довільну
кількість масивів в один новий. Раніше для цього використовували методи slice()
і concat(), але операція розподілу дозволяє зробити те саме у коротшій формі.
spread: створення нового об'єкта -- Операція ... (spread) дозволяє розподілити
властивості довільної кількості об'єктів в один новий. rest: збирання всіх
аргументів функції -- Операція ... (rest) дозволяє зібрати групу незалежних
елементів у нову колекцію. Синтаксично - це близнюк операції розподілу, але
відрізнити їх просто - розподіл - коли ... знаходиться у правій частині операції
присвоювання, а збирання - коли ... знаходиться в її лівій частині. Одна зі сфер
застосування операції rest - це створення функцій, які можуть приймати будь-яку
кількість аргументів. Колбек-функції Функції не відрізняються від чисел, рядків
або масивів - це просто спеціальний тип даних (об'єкт вищого порядку), значення,
яке можна зберігати у змінній або передавати у якості аргументу в іншу функцію.
Функція зворотного виклику (callback, колбек) - це функція, яка передається
іншій функції як аргумент, а та, в свою чергу, викликає передану функцію.
Функція вищого порядку (higher order function) - функція, яка приймає у якості
параметрів інші функції або повертає функцію у якості результату. Інлайн колбеки
Якщо колбек-функція - маленька, і потрібна тільки для передачі аргументом, її
можна оголосити безпосередньо на момент виклику функції, в яку передаємо колбек.
Така функція буде доступна тільки у якості значення параметра і більше ніде в
коді. Декілька колбеків Функція може приймати будь-яку кількість колбеків.
Колбеки застосовуються для обробки дій користувача на сторінці, на момент
обробки запитів на сервер, виконання заздалегідь невідомих функцій тощо. У цьому
і полягає їх суть - це функції, призначені для відкладеного виконання.
Абстрагування повторення Абстракція - приховування деталей реалізації. Дозволяє
думати про задачі на вищому (абстрактному) рівні. Функції - це хороший спосіб
побудови абстракцій. Наприклад, скрипт виконує якусь дію певну кількість разів.
Метод forEach Метод перебирання масиву, який використовується для заміни циклів
for і for...of в роботі з колекцією даних. массив.forEach(function
callback(element, index, array) { // Тіло колбек-функції }); Поелементо
перебирає масив. Викликає колбек-функцію для кожного елемента масиву. Нічого не
повертає. Аргументи колбек-функції - це значення поточного елемента element,
його індекс index і власне вихідний масив array. Можна оголошувати тільки
необхідні параметри, найчастіше - це елемент, головне не забувати про їх
порядок. Стрілочні функції мають скорочений, лаконічніший синтаксис, що зменшує
обсяг коду, особливо коли функція маленька або якщо вона використовується як
колбек. Усі стрілки створюються як функціональний вираз, і якщо функція - не
анонімна, її необхідно присвоювати змінній. Ключове слово function не
використовується, замість цього відразу зазначається оголошення параметрів,
після нього - символ => і тіло функції. Якщо параметрів декілька, то вони
перераховуються через кому в круглих дужках, між знаками дорівнює = і стрілкою
=>. Якщо параметр один, його можна оголошувати без круглих дужок. Якщо параметри
відсутні, то обов'язково повинні бути порожні круглі дужки. Неявне повернення У
стрілочної функції після символу => знаходиться її тіло. Існує два варіанти: з
фігурними дужками і без них. Якщо є фігурні дужки, і функція повинна повертати
якесь значення, необхідно явно поставити return. Це називається явне повернення
(explicit return). Такий синтаксис використовується у разі, якщо в тілі функції
потрібно виконати ще якісь інструкції, крім повернення значення. const add = (a,
b, c) => a + b + c; Якщо фігурні дужки відсутні, то повертається результат
виразу, який стоїть після =>. Це називається неявне повернення (implicit
return). У прикладі повернеться результат виразу додавання параметрів a, b і c.
Псевдомасив arguments У стрілочних функцій немає локальної змінної arguments, що
містить усі аргументи. Якщо необхідно зібрати всі аргументи в масив,
використовується операція rest. Стрілочні функції як колбеки Анонімні стрілочні
функції відмінно підходять як колбеки для перебираючих методів масиву завдяки
коротшому синтаксису оголошення, особливо, якщо не потрібне тіло функції.
Стрілочну колбек-функцію також можна оголошувати окремо і передавати на неї
посилання. Це варто робити, якщо одна функція використовується у декількох
місцях програми або якщо вона громіздка.

<!--                   Чисті функції               -->

Функція з побічними ефектами - це функція, яка в процесі виконання може
змінювати або використовувати глобальні змінні, змінювати значення аргументів
посилального типу, виконувати операції введення-виведення тощо. Чиста функція
(pure function) - це функція, результат якої залежить тільки від значень
переданих аргументів. За умови однакових аргументів вона завжди повертає один і
той самий результат і не має побічних ефектів, тобто не змінює значення
аргументів

<!-- Перебираючі методи масиву -->

В JavaScript є методи масивів, що прийшли з функціональних мов. Більшість з них
- це чисті функції. Вони створюють новий масив, заповнюють його, застосовуючи до
значення кожного елемента зазначену колбек-функцію, після чого повертають цей
новий масив. Усі перебираючі методи масивів мають схожий синтаксис. Вихідний
масив array, виклик методу method і callback-функція callback як аргумент
методу. array.method(callback[currentValue, index, array]) У більшості методів
аргументами callback-функції є значення елемента currentValue (перший параметр),
позиція елемента index (другий параметр) і сам вихідний масив array (третій
параметр). array.method((item, idx, arr) => { // логіка, яка буде
застосовуватися на кожній ітерації }); Всі параметри, крім значення елемента
item, - необов'язкові. Назви параметрів можуть бути будь-які, але є неофіційні
домовленості. array.method(item => { // логіка, яка буде застосовуватися на
кожній ітерації });

<!-- Метод map() -->

Метод map(callback) використовується для трансформації масиву. Він викликає
колбек-функцію для кожного елемента вихідного масиву, а результат її роботи
записує у новий масив, який і буде результатом виконання методу.
массив.map((element, index, array) => { // Тіло колбек-функції }); Поелементо
перебирає оригінальний масив. Не змінює оригінальний масив. Результат роботи
колбек-функції записується у новий масив. Повертає новий масив однакової
довжини. Його можна використовувати для того, щоб змінити кожен елемент масиву.
Оригінальний масив використовується як еталон, на основі якого можна зробити
іншу колекцію.

<!-- Масив об'єктів -->

Ми вже знаємо, що повсякденне завдання - це маніпуляція масивом об'єктів.
Наприклад, отримати масив значень властивості з усіх об'єктів. У нас є масив
студентів, а потрібно отримати окремий масив їхніх імен. Використовуючи метод
map(), ми можемо перебрати масив об'єктів, і в колбек-функції повернути значення
властивості кожного з них.

<!-- Метод flatMap() -->

Метод flatMap(callback) - аналогічний методу map(), але застосовується у
випадках, коли результат - це багатовимірний масив, який необхідно «розгладити».
массив.flatMap((element, index, array) => { // Тіло колбек-функції }); Він
викликає колбек-функцію для кожного елемента вихідного масиву, а результат її
роботи записує у новий масив. Відмінність від map() у тому, що новий масив
«розгладжується» на глибину, що дорівнює одиниці (одна вкладеність). Цей
розгладжений масив і є результатом роботи flatMap().

<!-- Метод filter() -->

Метод filter(callback) використовується для єдиної операції - фільтрації масиву,
тобто, коли необхідно вибрати більше одного елемента з колекції за певним
критерієм. масив.filter((element, index, array) => { // Тіло колбек-функції });

<!-- Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає новий масив.
Додає у масив, що повертається, елементи, які задовольняють умови колбек-функції.
Якщо колбек повернув true, елемент додається у масив, що повертається.
Якщо колбек повернув false, елемент не додається у масив, що повертається.
Якщо жоден елемент не задовольнив умову, повертає порожній масив. -->

<!-- Фільтрація унікальних елементів -->

Використовуючи метод filter(), можна виконати фільтрацію масиву таким чином, що
у ньому залишаться тільки унікальні елементи. Цей прийом працює тільки з масивом
примітивних значень - не об'єктів.

<!-- Масив об'єктів -->

Під час роботи з масивом об'єктів виконується фільтрація за значенням певної
властивості. У підсумку, утворюється новий масив відфільтрованих об'єктів.
Наприклад, у нас є масив студентів з балами за тест. Необхідно відфільтрувати
кращих (бал вище 80), гірших (бал нижче 50) і середніх студентів (бал від 50 до
80).

<!-- Метод find() -->

Якщо метод filter(cabllack) використовується для пошуку всіх елементів, що
задовольняють умову, то метод find(callback) дозволяє знайти і повернути перший
відповідний елемент, після чого перебирання масиву припиняється. Тобто він шукає
до першого збігу. масив.find((element, index, array) => { // Тіло колбек-функції
});

<!-- Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає перший елемент, що задовольняє умову, тобто коли колбек повертає true.
Якщо жоден елемент не задовольнив умову,
тобто для всіх елементів колбек повернув false, метод повертає undefined. -->

Метод find() використовується для одного завдання - пошуку елемента за
унікальним значенням властивості. Наприклад, пошук користувача за поштою,
автомобіля - за серійним номером, книги - за назвою тощо.

<!-- Метод findIndex() -->

Метод findIndex(callback) - це сучасна заміна методу indexOf(). Дозволяє
виконувати пошук за складнішими умовами, ніж просто рівність. Використовується
як для пошуку у масиві примітивів, так і в масиві об'єктів.
масив.findIndex((element, index, array) => { // Тіло колбек-функції });

<!-- Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає індекс першого елемента, що задовольняє умову,
тобто, коли колбек повертає true.
Якщо жоден елемент не задовольняє умову,
тобто для всіх елементів колбек повернув false, метод повертає -1. -->

<!-- Методи every() і some() -->
<!-- Метод every() -->

Перевіряє, чи проходять всі елементи масиву тест колбек-функції. Повертає true
або false. масив.every((element, index, array) => { // Тіло колбек-функції });

<!-- Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає true, якщо всі елементи масиву задовольняють умову.
Повертає false, якщо хоча б один елемент масиву не задовольняє умову.
Перебирання масиву припиняється, якщо колбек повертає false. -->

<!-- Метод some() -->

Перевіряє, чи проходить хоча б один елемент масиву тест колбек-функції. Повертає
true або false. масив.some((element, index, array) => { // Тіло колбек-функції
});

<!-- Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає true, якщо хоча б один елемент масиву задовольняє умову.
Повертає false, якщо жоден елемент масиву не задовольняє умову.
Перебирання масиву припиняється, якщо колбек повертає true. -->

Масив об'єктів Під час роботи з масивом об'єктів перевіряється значення певної
їх властивості. Наприклад, у нас є масив об'єктів фруктів, необхідно дізнатися,
чи є фрукти в наявності та чи є в наявності хоча б якісь фрукти, тобто більше 0
штук.

<!-- Метод reduce() -->

Метод reduce(callback, initialValue) використовується для послідовної обробки
кожного елемента масиву із збереженням проміжного результату, як акумулятор.
Трохи складніший за інші методи для засвоєння, але результат вартий того.
масив.reduce((previousValue, element, index, array) => { // Тіло колбек-функції
}, initialValue);

<!-- Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає все, що завгодно.
Робить все, що завгодно. -->

Перший параметр колбек-функції (previousValue) - це акумулятор, тобто проміжний
результат. Значення, яке поверне колбек-функція на поточній ітерації, буде
значенням цього параметра на наступній ітерації. Другим аргументом для reduce()
можна передати необов'язкове початкове значення акумулятора - параметр
initialValue. Тобто метод reduce() використовується, коли необхідно взяти
«багато» і привести до «одного». У повсякденних завданнях його застосування
зводиться до роботи з числами.

<!-- Просунутий reduce -->

Припустимо у нас є наступна задача: з масиву постів твіттера окремого
користувача необхідно порахувати суму усіх лайків. Можна перебрати циклом for
або forEach, кожне з цих рішень вимагатиме написання додаткового коду. А можна
використовувати reduce.

<!-- Метод sort() -->

Метод sort() сортує елементи масиву, але на відміну від інших методів
перебирання, він сортує вихідний масив.

<!-- Сортує і змінює вихідний масив.
Повертає змінений масив, тобто посилання на відсортований вихідний.
За замовчуванням сортує за зростанням.
Сортування відбувається шляхом приведення значень до рядка і 
порівняння порядкових номерів у таблиці Unicode. -->

Свій порядок сортування чисел Для зазначення свого порядку сортування методу
sort(compareFunction) потрібно передати колбек-функцію з двома параметрами. Це
функція порівняння (compare function), порядок сортування залежить від її
результату. Метод sort() буде викликати її для двох довільних елементів.

<!-- массив.sort((a, b) => {
  // Тіло колбек-функції
}); -->
<!-- a - перший елемент для порівняння. -->
<!-- b - другий елемент для порівняння. -->

<!-- Свій порядок сортування рядків -->

Для сортування рядків в алфавітному порядку, за зростанням або спаданням,
використовується метод рядків localeCompare().

<!-- firstString.localeCompare(secondString) -->

Він викликається на рядку, який потрібно порівняти (firstString) з тим, що був
переданий йому як аргумент (secondString). "a".localeCompare("b"); // -1
"b".localeCompare("a"); // 1 "a".localeCompare("a"); // 0
"b".localeCompare("b"); // 0

<!-- Повертає від'ємне значення, якщо firstString повинен бути перед secondString.
Повертає додатне значення більше нуля, якщо firstString повинен бути після secondString.
Якщо рядки однакові, повертається нуль. -->

Це зручно використовувати для сортування рядків, оскільки метод sort() очікує
такі самі значення від колбек-функції.

<!-- Сортування об'єктів -->

Під час роботи з масивом об'єктів, сортування виконується за числовим або
рядковим значенням певної властивості. Наприклад, у нас є група студентів з
балами за тест. Необхідно відсортувати масив об'єктів за зростанням і спаданням
кількості балів, і за ім'ям студента.

<!-- const students = [
  { name: "Манго", score: 83 },
  { name: "Полі", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Ківі", score: 94 },
];

const inAscendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
);

const inDescendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
);

const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
  firstStudent.name.localeCompare(secondStudent.name)
); -->

<!-- Ланцюжки методів -->

У нас є масив об'єктів з іменами, балами і відвідуваними предметами кожного
студента.

<!-- const students = [
  { name: "Манго", score: 83, courses: ["математика", "фізика"] },
  { name: "Полі", score: 59, courses: ["інформатика", "математика"] },
  { name: "Аякс", score: 37, courses: ["фізика", "біологія"] },
  { name: "Ківі", score: 94, courses: ["література", "інформатика"] },
]; -->

Позбутися таких «мертвих» змінних можна за допомогою групування викликів методів
у ланцюжку. Кожний наступний метод буде виконуватися на основі результату роботи
попереднього.

<!-- const names = [...students]
  .sort((a, b) => a.score - b.score)
  .map(student => student.name);

console.log(names); // ['Аякс', 'Полі', 'Манго', 'Ківі'] -->

<!-- Робимо копію вихідного масиву перед сортуванням.
На копії викликаємо метод sort().
До результату роботи методу sort() застосовуємо метод map().
Змінній names присвоюється результат роботи методу map(). -->

Отримаємо масив унікальних відвідуваних предметів, відсортований за алфавітом.

<!-- const uniqueSortedCourses = students
  .flatMap(student => student.courses)
  .filter((course, index, array) => array.indexOf(course) === index)
  .sort((a, b) => a.localeCompare(b));

console.log(uniqueSortedCourses); // ['біологія', 'інформатика', 'література', 'математика', 'фізика'] -->

<!-- На вихідному масиві викликаємо flatMap() і робимо розгладжений масив усіх курсів.
До результату методу flatMap() застосовуємо метод filter() для фільтрації унікальних елементів.
На результаті методу filter() викликаємо sort().
Змінній uniqueSortedCourses присвоюється результат роботи методу sort(). -->

<!--                  Контекст виконання функції                       -->

<!-- Правила визначення this -->

Необхідно засвоїти лише одне правило для визначення this - значення контексту
всередині функції (не стрілочної) визначається не на момент її створення, а на
момент виклику. Тобто значення this визначається тим, як викликається функція, а
не де вона була оголошена.
